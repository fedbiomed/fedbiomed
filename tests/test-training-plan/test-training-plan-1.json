{
  "clsname": "FakeTrainingPlan",
  "source": "import declearn\nfrom fedbiomed.common.data import DataLoaderTypes\nfrom fedbiomed.common.training_plans import TrainingPlan\n\nclass FakeTrainingPlan(TrainingPlan):\n    \"\"\"Fake fedbiomed TrainingPlan, wrapping a FakeDeclearnModel.\"\"\"\n\n    class FakeDeclearnModel(declearn.model.api.Model):\n        \"\"\"Fake declearn Model, exposing minimal effect-less API methods.\"\"\"\n\n        @property\n        def required_data_info(self):\n            return set()\n\n        def initialize(self, data_info):\n            pass\n\n        def get_config(self):\n            return {\"model\": None}\n\n        @classmethod\n        def from_config(cls, config):\n            return cls(**config)\n\n        def get_weights(self):\n            return declearn.model.api.NumpyVector({})\n\n        def set_weights(self, weights):\n            pass\n\n        def compute_batch_gradients(self, batch):\n            return declearn.model.api.NumpyVector({})\n\n        def apply_updates(self):\n            pass\n\n        def compute_loss(self, dataset):\n            return 0.\n\n    _model_cls=FakeDeclearnModel\n    _data_type=DataLoaderTypes.NUMPY.value\n\n    def __init__(\n            self,\n            model=None,\n            optim={\"lrate\": 0.01},  # NOTE: minimal config for Optimizer\n            **kwargs\n        ):\n        super().__init__(model, optim, **kwargs)\n        self.add_dependency([\n            \"import declearn\",\n            \"from fedbiomed.common.data import DataLoaderTypes\",\n            \"from fedbiomed.common.training_plans import TrainingPlan\",\n        ])\n\n    def predict(self, data):\n        pass  # NOTE: this does *not* respect the API\n",
  "dependencies": ["import declearn", "from fedbiomed.common.data import DataLoaderTypes", "from fedbiomed.common.training_plans import TrainingPlan"],
  "model": {"model": null},
  "optim": {"lrate": 0.01, "w_decay": 0.0, "modules": []}
}
